<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qingrenn.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="C++基础1 指针1.1空指针和野指针空指针：指针变量指向内存中编号为0的空间的 用途：初始化指针变量 注意：空指针指向的内存是不可以访问的 12345int main()&amp;#123;    int *p &#x3D; null;&#x2F;&#x2F;空指针    *p &#x3D; 100;    &#x2F;&#x2F;会引发异常，0~255之间内存空间为系统内存占用，不允许访问&amp;#125; 野指针:指针指向非法的内存空间 12345int main">
<meta property="og:type" content="article">
<meta property="og:title" content="C++笔记">
<meta property="og:url" content="https://qingrenn.github.io/2021/07/21/C++%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Qingren&#39;s Blog">
<meta property="og:description" content="C++基础1 指针1.1空指针和野指针空指针：指针变量指向内存中编号为0的空间的 用途：初始化指针变量 注意：空指针指向的内存是不可以访问的 12345int main()&amp;#123;    int *p &#x3D; null;&#x2F;&#x2F;空指针    *p &#x3D; 100;    &#x2F;&#x2F;会引发异常，0~255之间内存空间为系统内存占用，不允许访问&amp;#125; 野指针:指针指向非法的内存空间 12345int main">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/93963/AppData/Roaming/Typora/typora-user-images/image-20200912090643041.png">
<meta property="og:image" content="c:/Users/93963/AppData/Roaming/Typora/typora-user-images/image-20200912090759537.png">
<meta property="og:image" content="c:/Users/93963/AppData/Roaming/Typora/typora-user-images/image-20200915162841352.png">
<meta property="og:image" content="c:/Users/93963/AppData/Roaming/Typora/typora-user-images/image-20201001174515725.png">
<meta property="og:image" content="c:/Users/93963/AppData/Roaming/Typora/typora-user-images/image-20201001174515725.png">
<meta property="article:published_time" content="2021-07-20T16:00:00.000Z">
<meta property="article:modified_time" content="2021-09-29T08:21:27.696Z">
<meta property="article:author" content="Qingren">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/93963/AppData/Roaming/Typora/typora-user-images/image-20200912090643041.png">


<link rel="canonical" href="https://qingrenn.github.io/2021/07/21/C++%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://qingrenn.github.io/2021/07/21/C++%E7%AC%94%E8%AE%B0/","path":"2021/07/21/C++笔记/","title":"C++笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++笔记 | Qingren's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Qingren's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Reading and coding</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%8C%87%E9%92%88"><span class="nav-number">1.1.</span> <span class="nav-text">1 指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E7%A9%BA%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1空指针和野指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-const%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 const修饰指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3指针和数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4%E6%8C%87%E9%92%88%E5%92%8C%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4指针和函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.5冒泡排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.2.</span> <span class="nav-text">2 结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1结构体的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2结构体定义和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3结构体数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4结构体指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5结构体嵌套结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6结构体作为函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%ADconst%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.7.</span> <span class="nav-text">2.7结构体中const的使用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E6%A0%B8%E5%BF%83"><span class="nav-number">2.</span> <span class="nav-text">C++核心</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">1 内存分区模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-new%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1 new操作符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%BC%95%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text">2 引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1引用的基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E5%BC%95%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2引用注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E5%BC%95%E7%94%A8%E4%BD%9C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.3引用作函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4%E5%BC%95%E7%94%A8%E4%BD%9C%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.4引用作函数的返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">2.2.5.</span> <span class="nav-text">2.5引用的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="nav-number">2.2.6.</span> <span class="nav-text">2.6常量引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%87%BD%E6%95%B0%E7%9A%84%E6%8F%90%E9%AB%98"><span class="nav-number">2.3.</span> <span class="nav-text">3 函数的提高</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E5%BD%A2%E5%8F%82%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">2.3.1.</span> <span class="nav-text">3.1形参的默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E5%87%BD%E6%95%B0%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0"><span class="nav-number">2.3.2.</span> <span class="nav-text">3.2函数占位参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">2.3.3.</span> <span class="nav-text">3.3函数的重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E8%BF%B0"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">3.3.1函数重载概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">3.3.2函数重载的注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.</span> <span class="nav-text">4 类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E5%B0%81%E8%A3%85"><span class="nav-number">2.4.1.</span> <span class="nav-text">4.1封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1%E5%B0%81%E8%A3%85%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">4.1.1封装的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2struct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">4.1.2struct和class的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%A7%81%E6%9C%89"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">4.1.3成员属性设置为私有</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86"><span class="nav-number">2.4.2.</span> <span class="nav-text">4.2对象的初始化和清理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">4.2.1构造函数和析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">4.2.2构造函数的分类及调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">4.2.3拷贝构造函数调用时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">4.2.4构造函数调用规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-5%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">4.2.5深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">2.4.2.6.</span> <span class="nav-text">4.2.6初始化列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-7%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">2.4.2.7.</span> <span class="nav-text">4.2.7类对象作为类成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">2.4.2.8.</span> <span class="nav-text">4.2.8静态成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88"><span class="nav-number">2.4.3.</span> <span class="nav-text">4.3 C++对象模型和this指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%82%A8%E5%AD%98"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">4.3.1成员变量和成员函数分开储存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2this%E6%8C%87%E9%92%88%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">4.3.2this指针的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">4.3.3空指针访问成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.3.4.</span> <span class="nav-text">4.3.4const修饰成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4%E5%8F%8B%E5%85%83"><span class="nav-number">2.4.4.</span> <span class="nav-text">4.4友元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E4%BD%9C%E5%8F%8B%E5%85%83"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">4.4.1全局函数作友元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2%E7%B1%BB%E5%81%9A%E5%8F%8B%E5%85%83"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">4.4.2类做友元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="nav-number">2.4.4.3.</span> <span class="nav-text">4.4.3成员函数做友元</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.4.5.</span> <span class="nav-text">4.5运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-1%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">4.5.1加号运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">4.5.2左移运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-3%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.4.5.3.</span> <span class="nav-text">4.5.3递增运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-4%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.4.5.4.</span> <span class="nav-text">4.5.4赋值运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-5%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.4.5.5.</span> <span class="nav-text">4.5.5关系运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-6%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.4.5.6.</span> <span class="nav-text">4.5.6函数调用运算符重载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6%E7%BB%A7%E6%89%BF"><span class="nav-number">2.4.6.</span> <span class="nav-text">4.6继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-1%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">2.4.6.1.</span> <span class="nav-text">4.6.1继承的基本语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-2%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="nav-number">2.4.6.2.</span> <span class="nav-text">4.6.2继承方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-3%E9%9B%86%E6%88%90%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.4.6.3.</span> <span class="nav-text">4.6.3集成中的对象模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-4%E9%9B%86%E6%88%90%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.4.6.4.</span> <span class="nav-text">4.6.4集成中的构造和析构顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-5%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">2.4.6.5.</span> <span class="nav-text">4.6.5继承同名函数处理方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-6%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">2.4.6.6.</span> <span class="nav-text">4.6.6继承同名静态成员处理方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-7%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="nav-number">2.4.6.7.</span> <span class="nav-text">4.6.7多继承语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-8%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="nav-number">2.4.6.8.</span> <span class="nav-text">4.6.8菱形继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7%E5%A4%9A%E6%80%81"><span class="nav-number">2.4.7.</span> <span class="nav-text">4.7多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-1%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.4.7.1.</span> <span class="nav-text">4.7.1多态的基本类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-2%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">2.4.7.2.</span> <span class="nav-text">4.7.2多态的底层原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-3%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">2.4.7.3.</span> <span class="nav-text">4.7.3纯虚函数和抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-4%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span class="nav-number">2.4.7.4.</span> <span class="nav-text">4.7.4虚析构和纯虚析构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">2.5.</span> <span class="nav-text">5 文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="nav-number">2.5.1.</span> <span class="nav-text">5.1文本文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">5.1.1写文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">5.1.2读文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-number">2.5.2.</span> <span class="nav-text">5.2二进制文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">5.2.1写文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">5.2.2读文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B"><span class="nav-number">2.6.</span> <span class="nav-text">C++提高编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.7.</span> <span class="nav-text">1模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.7.1.</span> <span class="nav-text">1.1模板的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.7.2.</span> <span class="nav-text">1.2函数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">1.2.1函数模板语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">1.2.2函数模板注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B"><span class="nav-number">2.7.2.3.</span> <span class="nav-text">1.2.3函数模板案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.7.2.4.</span> <span class="nav-text">1.2.4普通函数与函数模板的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-5%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-number">2.7.2.5.</span> <span class="nav-text">1.2.5普通函数与函数模板的调用规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-6%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">2.7.2.6.</span> <span class="nav-text">1.2.6模板的局限性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.7.3.</span> <span class="nav-text">1.3类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">1.3.1类模板基本语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8C%BA%E5%88%AB"><span class="nav-number">2.7.3.2.</span> <span class="nav-text">1.3.2类模板与函数模板区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="nav-number">2.7.3.3.</span> <span class="nav-text">1.3.3类模板中成员函数创建时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-4%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">2.7.3.4.</span> <span class="nav-text">1.3.4类模板对象做函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-5%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">2.7.3.5.</span> <span class="nav-text">1.3.5类模板与继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-6%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.7.3.6.</span> <span class="nav-text">1.3.6类模板成员函数类外实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-7%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="nav-number">2.7.3.7.</span> <span class="nav-text">1.3.7类模板分文件编写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-8%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83"><span class="nav-number">2.7.3.8.</span> <span class="nav-text">1.3.8类模板与友元</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-STL"><span class="nav-number">2.8.</span> <span class="nav-text">2 STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.8.1.</span> <span class="nav-text">2.1STL基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="nav-number">2.8.2.</span> <span class="nav-text">2.2STL六大组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-STL%E4%B8%AD%E5%AE%B9%E5%99%A8%E3%80%81%E7%AE%97%E6%B3%95%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">2.8.3.</span> <span class="nav-text">2.3 STL中容器、算法、迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95%E5%8F%A0%E5%8A%A0%E5%99%A8%E5%88%9D%E8%AF%86"><span class="nav-number">2.8.4.</span> <span class="nav-text">2.4容器算法叠加器初识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-Vector%E5%AD%98%E6%94%BE%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.8.4.1.</span> <span class="nav-text">2.4.1 Vector存放内置数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-Vector%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.8.4.2.</span> <span class="nav-text">2.4.2 Vector存放自定义数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3Vector%E5%AE%B9%E5%99%A8%E5%B5%8C%E5%A5%97%E5%AE%B9%E5%99%A8"><span class="nav-number">2.8.4.3.</span> <span class="nav-text">2.4.3Vector容器嵌套容器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">2.8.5.</span> <span class="nav-text">3 STL常用容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1string"><span class="nav-number">2.8.6.</span> <span class="nav-text">3.1string</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1string%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.8.6.1.</span> <span class="nav-text">3.1.1string基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2string%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.8.6.2.</span> <span class="nav-text">3.1.2string构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3string%E7%9A%84%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.8.6.3.</span> <span class="nav-text">3.1.3string的赋值操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="nav-number">2.8.6.4.</span> <span class="nav-text">3.1.4string字符串拼接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="nav-number">2.8.6.5.</span> <span class="nav-text">3.1.5字符串查找和替换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-6%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">2.8.6.6.</span> <span class="nav-text">3.1.6字符串的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-7-string%E5%AD%97%E7%AC%A6%E5%AD%98%E5%8F%96"><span class="nav-number">2.8.6.7.</span> <span class="nav-text">3.1.7 string字符存取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-8-string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">2.8.6.8.</span> <span class="nav-text">3.1.8 string插入和删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-9-string%E5%AD%90%E4%B8%B2"><span class="nav-number">2.8.6.9.</span> <span class="nav-text">3.1.9 string子串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-vector%E5%AE%B9%E5%99%A8"><span class="nav-number">2.8.7.</span> <span class="nav-text">3.2 vector容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-vector%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.8.7.1.</span> <span class="nav-text">3.2.1 vector基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.8.7.2.</span> <span class="nav-text">3.2.2 vector构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-vector%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.8.7.3.</span> <span class="nav-text">3.2.3 vector赋值操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-vector%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.8.7.4.</span> <span class="nav-text">3.2.4 vector容量和大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">2.8.7.5.</span> <span class="nav-text">3.2.5 vector插入和删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-6-vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="nav-number">2.8.7.6.</span> <span class="nav-text">3.2.6 vector数据存取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-7-vector%E4%BA%92%E6%8D%A2%E5%AE%B9%E5%99%A8"><span class="nav-number">2.8.7.7.</span> <span class="nav-text">3.2.7 vector互换容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-8-vector%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4"><span class="nav-number">2.8.7.8.</span> <span class="nav-text">3.2.8 vector预留空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-deque%E5%AE%B9%E5%99%A8"><span class="nav-number">2.8.8.</span> <span class="nav-text">3.3 deque容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.8.8.1.</span> <span class="nav-text">3.3.1 deque容器基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.8.8.2.</span> <span class="nav-text">3.3.2 deque构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.8.8.3.</span> <span class="nav-text">3.3.3 deque赋值操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">2.8.8.4.</span> <span class="nav-text">3.3.4 deque大小操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-5-deque%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">2.8.8.5.</span> <span class="nav-text">3.3.5 deque插入和删除</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.</span> <span class="nav-text">注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-new%E5%87%BA%E6%9D%A5%E7%9A%84%E6%98%AF%E6%8C%87%E9%92%88"><span class="nav-number">3.1.</span> <span class="nav-text">1 new出来的是指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1-end-%E6%8C%87%E9%92%88"><span class="nav-number">3.2.</span> <span class="nav-text">2 容器对象.end()指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-explicit-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.3.</span> <span class="nav-text">3 explicit 关键字</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Qingren"
      src="https://github.com/Qingrenn/FigureBed/blob/master/avatar.gif?raw=true">
  <p class="site-author-name" itemprop="name">Qingren</p>
  <div class="site-description" itemprop="description">The palest ink is better than the best memory.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Qingrenn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Qingrenn" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yaoqingrenrobin@gmail.com" title="E-Mail → mailto:yaoqingrenrobin@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Qingrenn" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qingrenn.github.io/2021/07/21/C++%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://github.com/Qingrenn/FigureBed/blob/master/avatar.gif?raw=true">
      <meta itemprop="name" content="Qingren">
      <meta itemprop="description" content="The palest ink is better than the best memory.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qingren's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-21 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-21T00:00:00+08:00">2021-07-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-29 16:21:27" itemprop="dateModified" datetime="2021-09-29T16:21:27+08:00">2021-09-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h2 id="1-指针"><a href="#1-指针" class="headerlink" title="1 指针"></a>1 指针</h2><h3 id="1-1空指针和野指针"><a href="#1-1空指针和野指针" class="headerlink" title="1.1空指针和野指针"></a>1.1空指针和野指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间的</p>
<p>用途：初始化指针变量</p>
<p>注意：空指针指向的内存是不可以访问的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = null;<span class="comment">//空指针</span></span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//会引发异常，0~255之间内存空间为系统内存占用，不允许访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>野指针</strong>:指针指向非法的内存空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="number">0x1100</span>;<span class="comment">//野指针</span></span><br><span class="line">    std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//访问野指针报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p>
<span id="more"></span>
<h3 id="1-2-const修饰指针"><a href="#1-2-const修饰指针" class="headerlink" title="1.2 const修饰指针"></a>1.2 const修饰指针</h3><p>const修饰指针有三种情况:</p>
<ol>
<li>const修饰指针-常量指针</li>
<li>const修饰常量-指针常量</li>
<li>const既修饰指针，又修饰常量</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//const修饰的是指针，指针的指向可以改，指针指向的值不可以改</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line">    p1 = &amp;b;<span class="comment">//正确</span></span><br><span class="line">    <span class="comment">//*p1 = 100; 报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//const修饰的是常量，指针不可以改指针指向的值可以改</span></span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">    <span class="comment">//p2 = &amp;b; 报错</span></span><br><span class="line">    *p2 = b;<span class="comment">//正确</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量，值都不可以改</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line">   	<span class="comment">//p3 = &amp;b; 错误</span></span><br><span class="line">    <span class="comment">//*p3 = b; 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3指针和数组"><a href="#1-3指针和数组" class="headerlink" title="1.3指针和数组"></a>1.3指针和数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> * p = arr;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//p是一个整形的指针，加一后地址向后移动4字节</span></span><br><span class="line">        cout&lt;&lt; *p++ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4指针和函数"><a href="#1-4指针和函数" class="headerlink" title="1.4指针和函数"></a>1.4指针和函数</h3><p>作用：利用指针作函数的参数，可以修改实参的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递,可以修改实参的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *p1,<span class="keyword">int</span> *p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmep = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">swap</span>(<span class="number">10</span>,<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5冒泡排序"><a href="#1-5冒泡排序" class="headerlink" title="1.5冒泡排序"></a>1.5冒泡排序</h3><p>功能描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j  = <span class="number">0</span>;j &lt; length - <span class="number">1</span> -i;j++)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(*arr &gt; *arr+i)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = *arr+i;</span><br><span class="line">                *arr+i = *arr;</span><br><span class="line">                *arr = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-结构体"><a href="#2-结构体" class="headerlink" title="2 结构体"></a>2 结构体</h2><h3 id="2-1结构体的基本概念"><a href="#2-1结构体的基本概念" class="headerlink" title="2.1结构体的基本概念"></a>2.1结构体的基本概念</h3><p>结构体属于用户<strong>自定义的数据内型</strong>，允许用户储存不同的数据类型。</p>
<h3 id="2-2结构体定义和使用"><a href="#2-2结构体定义和使用" class="headerlink" title="2.2结构体定义和使用"></a>2.2结构体定义和使用</h3><p>语法:<code>struct 结构体名 &#123;结构体成员列表&#125;;</code></p>
<p>通过结构体创建变量名的方式有三种：</p>
<ul>
<li><code>struct 结构体名 变量名</code></li>
<li><code>struct 结构体名 变量名 =  &#123;成员值1,成员值2...&#125;</code></li>
<li><code>定义结构体时顺便创建变量</code> </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//方式一 创建结构体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span>;</span><span class="comment">//struct关键字可以省略</span></span><br><span class="line">    s1.name = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">    s1.age = <span class="number">18</span>;</span><br><span class="line">    s1.score = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式二</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s2</span> =</span> &#123;<span class="string">&quot;Qingren&quot;</span>,<span class="number">20</span>,<span class="number">100</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式三</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;s3;</span><br></pre></td></tr></table></figure>
<h3 id="2-3结构体数组"><a href="#2-3结构体数组" class="headerlink" title="2.3结构体数组"></a>2.3结构体数组</h3><p><strong>作用</strong>：将自定义的结构体放入到数组中方便维护</p>
<p><strong>语法</strong>：<code>struct 结构体名 数组名[元素个数] = &#123; &#123;&#125;,&#123;&#125;,&#123;&#125;...&#125;</code></p>
<h3 id="2-4结构体指针"><a href="#2-4结构体指针" class="headerlink" title="2.4结构体指针"></a>2.4结构体指针</h3><p><strong>作用</strong>：通过指针访问结构体中的成员</p>
<ul>
<li>利用操作符<code>-&gt;</code>可以通过结构体指针访问结构体属性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student s1 = &#123;<span class="string">&quot;Qingren&quot;</span>,<span class="number">20</span>,<span class="number">100</span>&#125;;</span><br><span class="line">    Student *p = &amp;s1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;score：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5结构体嵌套结构体"><a href="#2-5结构体嵌套结构体" class="headerlink" title="2.5结构体嵌套结构体"></a>2.5结构体嵌套结构体</h3><p><strong>作用</strong>：结构体中的成员可以是另一个结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义学生结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义教师结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-6结构体作为函数参数"><a href="#2-6结构体作为函数参数" class="headerlink" title="2.6结构体作为函数参数"></a>2.6结构体作为函数参数</h3><p><strong>作用</strong>：将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<ul>
<li>值传递</li>
<li>引用传递</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(Student stu)</span></span>&#123;</span><br><span class="line">    stu.age = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; stu.name &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent_</span><span class="params">(Student *stu)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; stu-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7结构体中const的使用场景"><a href="#2-7结构体中const的使用场景" class="headerlink" title="2.7结构体中const的使用场景"></a>2.7结构体中const的使用场景</h3><p><strong>作用</strong>：用const防止误操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(Student stu)</span></span>&#123;</span><br><span class="line">    stu.age = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; stu.name &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用传递,如果结构体的成员变量太多，通过值传递的形式，需要复制出一个副本，消耗大量内存，通过const修饰结构体指针，禁止修改指针所指内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent_</span><span class="params">(<span class="keyword">const</span> Student *stu)</span></span>&#123;</span><br><span class="line">    <span class="comment">//stu-&gt;age = 15; 错误</span></span><br><span class="line">    cout &lt;&lt; stu-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-核心"><a href="#C-核心" class="headerlink" title="C++核心"></a>C++核心</h1><h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为4个区域</p>
<ul>
<li>代码区：存放函数的二进制代码，由操作系统进行管理</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放内存，存放函数的参数值、局部变量等</li>
<li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期，使编程更灵活</p>
<p><strong>栈区数据注意事项</strong>：</p>
<p>不要返回局部变量地址，局部变量存放在栈区，栈区的数据在函数执行完成后会自动释放</p>
<p><strong>堆区</strong>：</p>
<ul>
<li><p>在堆区开辟空间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">func</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//利用new关键字可以将数据开辟到堆区</span></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-1-new操作符"><a href="#1-1-new操作符" class="headerlink" title="1.1 new操作符"></a>1.1 new操作符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">fuc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">fuc2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建10整型的数组在堆区</span></span><br><span class="line">    <span class="keyword">int</span> * p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        *(p+i) = <span class="number">100</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="built_in">fuc</span>();</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="built_in">fuc2</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        cout &lt;&lt; *(p2 + i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1引用的基本使用"><a href="#2-1引用的基本使用" class="headerlink" title="2.1引用的基本使用"></a>2.1引用的基本使用</h3><p><strong>作用</strong>：给变量取别名</p>
<p><strong>语法</strong>：<code>数据类型 &amp;别名 = 原名</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2引用注意事项"><a href="#2-2引用注意事项" class="headerlink" title="2.2引用注意事项"></a>2.2引用注意事项</h3><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b;<span class="comment">//错误 引用必须初始化 int &amp;b = a;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-3引用作函数参数"><a href="#2-3引用作函数参数" class="headerlink" title="2.3引用作函数参数"></a>2.3引用作函数参数</h3><p><strong>作用</strong>：函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点</strong>： 可以简化指针修改实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_2</span><span class="params">(<span class="keyword">int</span> * a ,<span class="keyword">int</span> * b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_3</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    <span class="keyword">int</span> a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4引用作函数的返回值"><a href="#2-4引用作函数的返回值" class="headerlink" title="2.4引用作函数的返回值"></a>2.4引用作函数的返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p>
<p><strong>注意</strong>：不要返回局部变量引用</p>
<p>引用：函数调用作为左值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不要返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//局部变量放在栈区</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//静态变量放在全局区</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span> &amp;ref2 = <span class="built_in">test02</span>();<span class="comment">//ref2也为a的引用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">test02</span>() = <span class="number">1000</span>;<span class="comment">//返回的是静态变量a的引用</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5引用的本质"><a href="#2-5引用的本质" class="headerlink" title="2.5引用的本质"></a>2.5引用的本质</h3><p><strong>本质</strong>：引用的本质在c++内部实现是一个<strong>指针常量</strong></p>
<p>引用一旦初始化后，就不可发生改变是因为在指针常量中有const修饰，不可以再指向别的空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int * const ref = &amp;a;指针常量是指针指向不可改，这也说明为什么引用不可改</span></span><br><span class="line">    <span class="keyword">int</span>&amp; ref = a;</span><br><span class="line">    ref = <span class="number">20</span>;<span class="comment">//内部发现ref是引用，自动帮我们转化为:*ref = 20;</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6常量引用"><a href="#2-6常量引用" class="headerlink" title="2.6常量引用"></a>2.6常量引用</h3><p><strong>作用</strong>：常量引用主要是用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加const修饰形参，防止形参改变实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//int &amp; ref = 10; 错误 不能够引用常量</span></span><br><span class="line">    <span class="comment">//加上const之后编译器将代码修改 int temp = 10;const int &amp; ref = temp;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp; ref = <span class="number">10</span>;<span class="comment">//引用必须引一块合法的内存空间</span></span><br><span class="line">    <span class="comment">// ref = 20; ref 错误 加入const之后，变为只读，不可修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//val = 100; 错误 使用const 修饰为引用常量，不能修改</span></span><br><span class="line">    <span class="comment">//这样用来修饰形参，防止误操作</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val = &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-函数的提高"><a href="#3-函数的提高" class="headerlink" title="3 函数的提高"></a>3 函数的提高</h2><h3 id="3-1形参的默认值"><a href="#3-1形参的默认值" class="headerlink" title="3.1形参的默认值"></a>3.1形参的默认值</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的；</p>
<p>语法：<code>返回值类型 函数名 (参数 = 默认值)&#123;&#125;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果我们自己传入数据，就用自己的数据，如果没有，就用默认值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">20</span>, <span class="keyword">int</span> c = <span class="number">30</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果某个位置已经有默认参数，那么从这个位置往后，从左到右都必须有默认值</span></span><br><span class="line"><span class="comment">//int fun2(int a,int b = 10,int c,int d)&#123;&#125; 错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数的声明有默认参数，那么函数的实现就不能有默认参数了</span></span><br><span class="line"><span class="comment">//声明和实现只能一个有参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun3</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>,<span class="keyword">int</span> b = <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="comment">//int fun3(int a = 10,int b = 20)&#123;&#125; 错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun3</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2函数占位参数"><a href="#3-2函数占位参数" class="headerlink" title="3.2函数占位参数"></a>3.2函数占位参数</h3><p>C++函数的形参列表中可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p>语法：<code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数占位参数，占位参数也可以有默认参数</span></span><br><span class="line"><span class="comment">//void func(int a,int = 10)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this i func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>);<span class="comment">//占位符必须填补</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3函数的重载"><a href="#3-3函数的重载" class="headerlink" title="3.3函数的重载"></a>3.3函数的重载</h3><h4 id="3-3-1函数重载概述"><a href="#3-3-1函数重载概述" class="headerlink" title="3.3.1函数重载概述"></a>3.3.1函数重载概述</h4><p><strong>作用</strong>：函数名可以相同，提高复用性</p>
<p><strong>函数重载满足的条件</strong>：</p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型</strong>不同或则个数不同或者<strong>顺序</strong>不同</li>
</ul>
<p><strong>注意</strong>：函数的返回值不可以作为函数重载的条件</p>
<h4 id="3-3-2函数重载的注意事项"><a href="#3-3-2函数重载的注意事项" class="headerlink" title="3.3.2函数重载的注意事项"></a>3.3.2函数重载的注意事项</h4><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun(int &amp;a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun(const int &amp;a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(a);<span class="comment">//调用的时fun(int &amp;a),因为a相当于是一个可读可写的变量</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用fun(const int &amp;a)</span></span><br><span class="line">    <span class="comment">//调用fun(int &amp;a)-- int &amp;a = 10不合法，因为10是一个常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun2(int a,int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun2(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//fun2(5); 错误，出现了二义性，报错，要尽量避免</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a>4 类和对象</h2><p>C++面向对象的三大特性：封装、继承、多态</p>
<p>C++认为万事万物皆为对象，对象上有其属性和行为</p>
<h3 id="4-1封装"><a href="#4-1封装" class="headerlink" title="4.1封装"></a>4.1封装</h3><h4 id="4-1-1封装的意义"><a href="#4-1-1封装的意义" class="headerlink" title="4.1.1封装的意义"></a>4.1.1封装的意义</h4><p>封装是C++面向对象的三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事务</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一</strong>：</p>
<p>在设计类的时候，属性和行为写在一起，表现事务</p>
<p>语法：class 类名{访问权限：属性/行为};</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line"><span class="comment">//访问权限</span></span><br><span class="line"><span class="keyword">public</span>：  </span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">int</span> m_r;</span><br><span class="line"><span class="comment">//行为</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculateZC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*PI*m_r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Circle c1;<span class="comment">//实例化</span></span><br><span class="line">    cl.mr = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的周长 = &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>封装意义二</strong>：</p>
<p>类在设计的时候，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<p>1.public    公共权限       类内可以访问，类外可以访问</p>
<p>2.protected 保护权限    类内可以访问，类外不可以访问，子类能够访问</p>
<p>3.private    私有权限      类内可以访问，类外不可以访问，子类无法访问</p>
<h4 id="4-1-2struct和class的区别"><a href="#4-1-2struct和class的区别" class="headerlink" title="4.1.2struct和class的区别"></a>4.1.2struct和class的区别</h4><p>在C++中struct和class唯一的区别就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct默认权限为公共</li>
<li>class默认权限为私有</li>
</ul>
<h4 id="4-1-3成员属性设置为私有"><a href="#4-1-3成员属性设置为私有" class="headerlink" title="4.1.3成员属性设置为私有"></a>4.1.3成员属性设置为私有</h4><p><strong>优点1</strong>：将成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2</strong>：对于写权限，我们可以检测数据的有效性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age_)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age_&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        age = age_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">int</span> name_)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name_ &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        name = name_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-2对象的初始化和清理"><a href="#4-2对象的初始化和清理" class="headerlink" title="4.2对象的初始化和清理"></a>4.2对象的初始化和清理</h3><h4 id="4-2-1构造函数和析构函数"><a href="#4-2-1构造函数和析构函数" class="headerlink" title="4.2.1构造函数和析构函数"></a>4.2.1构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>一个对象或者变量没有初试状态，对其使用的后果是未知的</p>
<p>同样使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>C++利用了<strong>构造函数和析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要求我们做的事情，因此如果<strong>我们不提供构造和折构，编译器会提供编译器提供的构造函数和折构函数是空实现的</strong>。</p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。</li>
<li>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。</li>
</ul>
<p>构造函数语法：<code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次</li>
</ol>
<p>析构函数语法：<code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同，在名称前加上符号 ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构函数，无须手动调用，而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person 构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Perosn 析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-2-2构造函数的分类及调用"><a href="#4-2-2构造函数的分类及调用" class="headerlink" title="4.2.2构造函数的分类及调用"></a>4.2.2构造函数的分类及调用</h4><p>两种分类方式：</p>
<ul>
<li>按参数分类：有参构造和无参构造</li>
<li>按类型分类：普通构造和拷贝构造</li>
</ul>
<p>三种调用方式：</p>
<ul>
<li>括号法</li>
<li>显式法</li>
<li>隐式转换法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    <span class="built_in">Person</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> a)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person &amp;p)&#123;</span><br><span class="line">        age = p.age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、括号法</span></span><br><span class="line">    Person p1;<span class="comment">//默认构造函数调用，注意不要加()</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;<span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="comment">//2、显式法</span></span><br><span class="line">    Person p1;</span><br><span class="line">    Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>);<span class="comment">//有参构造</span></span><br><span class="line">    Person p3 = <span class="built_in">Person</span>(p2);<span class="comment">//拷贝构造</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="number">10</span>);<span class="comment">//匿名对象 特点：当前行执行完后，系统会立即回收掉匿名对象</span></span><br><span class="line">    <span class="comment">//Person(p3);	错误，注意不要使用拷贝构造函数初始化匿名对象，编译器会认为Person(p3)-&gt;Person p3;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、隐式转换法</span></span><br><span class="line">    Person p4 = <span class="number">10</span>;<span class="comment">//有参构造-&gt;Person p4 = Person(10);</span></span><br><span class="line">    Perosn p4 = p5;<span class="comment">//拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-2-3拷贝构造函数调用时机"><a href="#4-2-3拷贝构造函数调用时机" class="headerlink" title="4.2.3拷贝构造函数调用时机"></a>4.2.3拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    Person p2 = <span class="built_in">Person</span>(p1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//情况二</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    <span class="built_in">doWork</span>(p1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//情况三</span></span><br><span class="line"><span class="function">Person <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Perosn p1;</span><br><span class="line">    <span class="keyword">return</span> p1;<span class="comment">//返回的是p1对象的拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">doWork</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-4构造函数调用规则"><a href="#4-2-4构造函数调用规则" class="headerlink" title="4.2.4构造函数调用规则"></a>4.2.4构造函数调用规则</h4><p> 默认情况下，c++编译器至少给一个类添加三个函数</p>
<p>1.默认构造函数（无参，函数体为空）</p>
<p>2.默认析构函数（无参，函数体为空）</p>
<p>3.默认拷贝函数，对属性进行拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li>如果用户定义有参构造函数，C++不再提供默认无参构造，但是会提供默认拷贝函数</li>
<li>如果用户定义拷贝构造函数，C++不会再提供其他构造函数</li>
</ul>
<h4 id="4-2-5深拷贝与浅拷贝"><a href="#4-2-5深拷贝与浅拷贝" class="headerlink" title="4.2.5深拷贝与浅拷贝"></a>4.2.5深拷贝与浅拷贝</h4><p>深拷贝是经典面试题，也是常见的坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>浅拷贝带来的问题就是堆区内存的重复释放</strong>：</p>
<p><img src="C:\Users\93963\AppData\Roaming\Typora\typora-user-images\image-20200912090643041.png" alt="image-20200912090643041" style="zoom:150%;" /></p>
<p><strong>深拷贝通过重新创建一个堆区内存，解决堆区内存重复释放的问题：</strong></p>
<p><img src="C:\Users\93963\AppData\Roaming\Typora\typora-user-images\image-20200912090759537.png" alt="image-20200912090759537"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age,<span class="keyword">int</span> height)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_age = age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(height);<span class="comment">//开辟堆空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深拷贝</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person &amp;p)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_age = p.m_age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p.m_height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在析构函数中释放堆空间</span></span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(m_height != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> m_height;</span><br><span class="line">            m_height = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *m_height;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">int</span> * m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p1 = <span class="built_in">Person</span>(<span class="number">10</span>,<span class="number">180</span>);</span><br><span class="line">    Person p2 = <span class="built_in">Person</span>(p1);</span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">getAge</span>() &lt;&lt; <span class="string">&quot;/&quot;</span>&lt;&lt;p2.<span class="built_in">getHeight</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-6初始化列表"><a href="#4-2-6初始化列表" class="headerlink" title="4.2.6初始化列表"></a>4.2.6初始化列表</h4><p>作用：C++提供了初始化列表的语法，用来初始化属性</p>
<p>语法：<code>构造函数():属性1(值1),属性2(值2)...()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//传统初始化</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)&#123;</span><br><span class="line">        m_a = a;</span><br><span class="line">        m_b = b;</span><br><span class="line">        m_c = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化列表的方式</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c):<span class="built_in">m_a</span>(a),<span class="built_in">m_b</span>(b),<span class="built_in">m_c</span>(c)&#123;&#125;</span><br><span class="line">    <span class="comment">//Person():m_a(10),m_b(20),m_c(30)&#123;&#125;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-7类对象作为类成员"><a href="#4-2-7类对象作为类成员" class="headerlink" title="4.2.7类对象作为类成员"></a>4.2.7类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为对象成员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">class B&#123;</span><br><span class="line">	A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当其它类对象作为本类成员，构造时先构造类对象，再构造自身</p>
<p>析构时，先析构自身，再析构类对象</p>
<h4 id="4-2-8静态成员"><a href="#4-2-8静态成员" class="headerlink" title="4.2.8静态成员"></a>4.2.8静态成员</h4><p>静态成员就是在成员变量和成员函数之前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ol>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li><strong>类内声明，类外初始化</strong></li>
</ol>
</li>
<li>静态成员函数<ol>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
<li>静态成员函数也是有访问权限的，private 修饰的话，无法类外访问</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    	m_A = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//m_B = 20; 错误 静态函数无法调用非静态成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">int</span> m_B = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类内声明，必须在类外初始化</span></span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//直接通过类调用</span></span><br><span class="line">    Person::<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//通过对象调用</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1成员变量和成员函数分开储存"><a href="#4-3-1成员变量和成员函数分开储存" class="headerlink" title="4.3.1成员变量和成员函数分开储存"></a>4.3.1成员变量和成员函数分开储存</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_A;<span class="comment">//非静态变量 属于类的对象上</span></span><br><span class="line">    satic <span class="keyword">int</span> m_B;<span class="comment">//静态成员变量        不属于类对象上</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//非静态成员函数	     不属于类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//静态成员函数 不属于类的对象上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Person::m_B = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="comment">//空对象占用内存空间为1</span></span><br><span class="line">    <span class="comment">//C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占用内存的位置，而且每个空对象也应该有一个独一无二的内存地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-2this指针的概念"><a href="#4-3-2this指针的概念" class="headerlink" title="4.3.2this指针的概念"></a>4.3.2this指针的概念</h4><p>C++通过提供特殊的对象指针，this指针，<strong>this指针指向被调用的成员函数所属的对象</strong>。</p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途 </p>
<ul>
<li>当形参和成员变量同名时，可以用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return * this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Perosn&amp; <span class="title">addAge</span><span class="params">(Person &amp;p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p1 = <span class="built_in">Person</span>(<span class="number">10</span>);</span><br><span class="line">    Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    p2.<span class="built_in">addAge</span>(p1).<span class="built_in">addAge</span>(p1).<span class="built_in">addAge</span>(p1);</span><br><span class="line">    cout &lt;&lt; p2.age &lt;&lt; endl;<span class="comment">//输出40</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果addAge函数返回对象而不是对象的引用，则输出20</span></span><br><span class="line"><span class="comment">//因为每次调用，返回的都是对象的拷贝，而不是对象本身</span></span><br><span class="line"><span class="comment">//Perosn addAge(Person &amp;p)&#123;</span></span><br><span class="line"><span class="comment">//        this-&gt;age += p.age;</span></span><br><span class="line"><span class="comment">//        return *this;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-3-3空指针访问成员函数"><a href="#4-3-3空指针访问成员函数" class="headerlink" title="4.3.3空指针访问成员函数"></a>4.3.3空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码健壮性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showClassName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是Person类&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(<span class="keyword">this</span> == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name = &quot;</span> &lt;&lt; name &lt;&lt; endl;    </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person *p = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">showClassName</span>();</span><br><span class="line">    <span class="comment">//p-&gt;showPerson();	错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-4const修饰成员函数"><a href="#4-3-4const修饰成员函数" class="headerlink" title="4.3.4const修饰成员函数"></a>4.3.4const修饰成员函数</h4><p><strong>常函数</strong>：</p>
<ul>
<li>成员函数后加const后我们称为这个函数为常函数</li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="comment">//this指针的本质是指针常量，指针的指向是不可以修改的</span></span><br><span class="line">    <span class="comment">//在成员函数后面添加const，修饰的是this指向，让指针指向的值也不能修改</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="comment">//this-&gt;m_A = 100;	错误</span></span><br><span class="line">    	<span class="comment">//this = NULL;	错误</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> m_B;<span class="comment">//特殊变量，即使在常函数中，也可以修改这个值，加关键字mutabel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Person p;<span class="comment">//在对象前加const 变为常对象</span></span><br><span class="line">    <span class="comment">//p.m_A = 100;	错误</span></span><br><span class="line">    p.m_B = <span class="number">100</span>;<span class="comment">//m_B是特殊值，在常对象下也可以修改</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//常对象只能调用常函数</span></span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4友元"><a href="#4-4友元" class="headerlink" title="4.4友元"></a>4.4友元</h3><h4 id="4-4-1全局函数作友元"><a href="#4-4-1全局函数作友元" class="headerlink" title="4.4.1全局函数作友元"></a>4.4.1全局函数作友元</h4><p>友元的目的就是让一个函数或者类访问另一个类中的私有成员</p>
<p>友元的关键字为friend</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>&#123;</span></span><br><span class="line">	<span class="comment">//goodFriend可以访问Building中的私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodFriend</span><span class="params">(Buiding *bulding)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;<span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodFriend</span><span class="params">(Buiding *bulding)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好朋友全局函数&quot;</span> &lt;&lt; building -&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-2类做友元"><a href="#4-4-2类做友元" class="headerlink" title="4.4.2类做友元"></a>4.4.2类做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>&#123;</span></span><br><span class="line">    <span class="comment">//类做友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodFriend</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();<span class="comment">//在类内声明，在类外实现</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodFriend</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodFriend</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GoodFriend::<span class="built_in">GoodFriend</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GoodFriend::visit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//GoodFriend类中的方法可以访问Building类中的私有成员变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-3成员函数做友元"><a href="#4-4-3成员函数做友元" class="headerlink" title="4.4.3成员函数做友元"></a>4.4.3成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>&#123;</span></span><br><span class="line">    <span class="comment">//类做友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">GoodFriend::visit2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();<span class="comment">//在类内声明，在类外实现</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodFriend</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodFriend</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit2</span><span class="params">()</span></span>;</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GoodFriend::<span class="built_in">GoodFriend</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GoodFriend::visit1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//该函数无法访问Building类的私有变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GoodFriend::visit2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//该方法作为Buidling类的友元，可以访问Building类中的私有成员变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5运算符重载"><a href="#4-5运算符重载" class="headerlink" title="4.5运算符重载"></a>4.5运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其一种功能，以适应不同的数据类型</p>
<h4 id="4-5-1加号运算符重载"><a href="#4-5-1加号运算符重载" class="headerlink" title="4.5.1加号运算符重载"></a>4.5.1加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员函数重载加号</span></span><br><span class="line">    Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person &amp;p2)&#123;</span><br><span class="line">        Person tmp = <span class="built_in">Person</span>(*<span class="keyword">this</span>);</span><br><span class="line">        tmp.a += p2.a;</span><br><span class="line">        tmp.b += p2.b;</span><br><span class="line">        <span class="keyword">return</span> tmp; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数重载加号</span></span><br><span class="line"><span class="comment">// Person operator+(Person &amp;p1,Person &amp;p2)&#123;</span></span><br><span class="line"><span class="comment">//     Person tmp;</span></span><br><span class="line"><span class="comment">//     tmp.a = p1.a + p2.a;</span></span><br><span class="line"><span class="comment">//     tmp.b = p1.b + p2.b;</span></span><br><span class="line"><span class="comment">//     return tmp;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数重载加号</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1,<span class="keyword">int</span> x)&#123;</span><br><span class="line">    Person p = <span class="built_in">Person</span>(p1.a + x, p1.b + x);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p1 = <span class="built_in">Person</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    Person p2 = <span class="built_in">Person</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">    Person p3 = p1 + p2;</span><br><span class="line">    Person p4 = p1 + <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; p3.a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; p3.b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; p4.a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; p4.b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-5-2左移运算符重载"><a href="#4-5-2左移运算符重载" class="headerlink" title="4.5.2左移运算符重载"></a>4.5.2左移运算符重载</h4><p><strong>作用：</strong>可以输出自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左移运算符重载</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能通过全局函数重载左移运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,Person &amp;p)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; p.<span class="built_in">getA</span>() &lt;&lt; <span class="string">&quot; b = &quot;</span> &lt;&lt; p.<span class="built_in">getB</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p1 = <span class="built_in">Person</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-5-3递增运算符重载"><a href="#4-5-3递增运算符重载" class="headerlink" title="4.5.3递增运算符重载"></a>4.5.3递增运算符重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; cout,MyInteger &amp;myint);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyInteger</span>(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载左++</span></span><br><span class="line">    MyInteger &amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        ++(<span class="keyword">this</span>-&gt;x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载右++</span></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">        MyInteger tmp = *<span class="keyword">this</span>;</span><br><span class="line">        (<span class="keyword">this</span>-&gt;x)++;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; cout,MyInteger &amp;myint)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; myint.x;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyInteger m = <span class="built_in">MyInteger</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; m++ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-5-4赋值运算符重载"><a href="#4-5-4赋值运算符重载" class="headerlink" title="4.5.4赋值运算符重载"></a>4.5.4赋值运算符重载</h4><p>C++编译器至少给一个类添加4个函数 </p>
<ol>
<li>默认构造函数 </li>
<li>默认析构函数 </li>
<li>默认拷贝函数 </li>
<li>赋值运算符operator=，对属性进行拷贝</li>
</ol>
<p><strong>如果类中右属性指向堆区，做赋值操作时也会出现深拷贝和浅拷贝的问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="comment">//this-&gt;age = age;</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(age != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> age;</span><br><span class="line">            age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载赋值运算符</span></span><br><span class="line">    Person &amp;<span class="keyword">operator</span>=(Person &amp;p1)&#123;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;赋值运算符重载&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p1.age);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p1 = <span class="built_in">Person</span>(<span class="number">18</span>);</span><br><span class="line">    Person p2 = p1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.Age = &quot;</span> &lt;&lt; p1.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.Age = &quot;</span> &lt;&lt; p2.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-5-5关系运算符重载"><a href="#4-5-5关系运算符重载" class="headerlink" title="4.5.5关系运算符重载"></a>4.5.5关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(string name,<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//重载==运算符</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(Person &amp;p1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getName</span>() == p1.<span class="built_in">getName</span>() &amp;&amp; <span class="keyword">this</span>-&gt;<span class="built_in">getAge</span>() == p1.<span class="built_in">getAge</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//重载！=运算符</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(Person &amp;p1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*<span class="keyword">this</span> == p1)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p1 = <span class="built_in">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    Person p2 = <span class="built_in">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if(p1 == p2)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;p1 = p2&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// else</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;p1 != p2&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p1 != p2)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 != p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 = p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-5-6函数调用运算符重载"><a href="#4-5-6函数调用运算符重载" class="headerlink" title="4.5.6函数调用运算符重载"></a>4.5.6函数调用运算符重载</h4><ul>
<li>函数调用运算符()也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此被称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数非常的灵活，没有固定的写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyPrint mp;</span><br><span class="line">    <span class="built_in">mp</span>(<span class="string">&quot;hello world!&quot;</span>);<span class="comment">//使用起来非常类似于函数的调用，因此被称为仿函数</span></span><br><span class="line">    MyAdd ma;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ma</span>(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用匿名函数对象</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>,<span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-6继承"><a href="#4-6继承" class="headerlink" title="4.6继承"></a>4.6继承</h3><p><strong>继承是面向对象的三大特性之一</strong></p>
<h4 id="4-6-1继承的基本语法"><a href="#4-6-1继承的基本语法" class="headerlink" title="4.6.1继承的基本语法"></a>4.6.1继承的基本语法</h4><p><code>class A:public B</code></p>
<p>A类称为子类或派生类 </p>
<p>B类称为父类或基类</p>
<p><strong>继承的好处：</strong>减少重复代码</p>
<h4 id="4-6-2继承方式"><a href="#4-6-2继承方式" class="headerlink" title="4.6.2继承方式"></a>4.6.2继承方式</h4><p>继承的语法：<code>class 子类 ：继承方式　方式</code></p>
<p><strong>继承方式一共有三种</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img src="C:\Users\93963\AppData\Roaming\Typora\typora-user-images\image-20200915162841352.png" alt="image-20200915162841352"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Father&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">10</span>;<span class="comment">//父类中的公共权限成员-&gt;子类中依然是公共权限</span></span><br><span class="line">        b = <span class="number">10</span>;<span class="comment">//父类中的保护权限成员-&gt;子类中依然是保护权限</span></span><br><span class="line">        <span class="comment">//c = 10; 父类中的私有权限成员，子类访问不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span><span class="keyword">protected</span> Father&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">10</span>;<span class="comment">//父类中的公共权限成员-&gt;子类中是保护权限</span></span><br><span class="line">        b = <span class="number">10</span>;<span class="comment">//父类中的保护权限成员-&gt;子类中依然是保护权限</span></span><br><span class="line">        <span class="comment">//c = 10; 父类中的私有权限成员，子类访问不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span><span class="keyword">protected</span> Father&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">10</span>;<span class="comment">//父类中的公共权限成员-&gt;子类中是保护权限</span></span><br><span class="line">        b = <span class="number">10</span>;<span class="comment">//父类中的保护权限成员-&gt;子类中依然是保护权限</span></span><br><span class="line">        <span class="comment">//c = 10; 父类中的私有权限成员，子类访问不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span> :</span><span class="keyword">private</span> Father&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//a = 10;父类中的公共权限成员-&gt;子类中是私有权限</span></span><br><span class="line">        <span class="comment">//b = 10;父类中的保护权限成员-&gt;子类中是私有权限</span></span><br><span class="line">        <span class="comment">//c = 10; 父类中的私有权限成员，子类访问不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-6-3集成中的对象模型"><a href="#4-6-3集成中的对象模型" class="headerlink" title="4.6.3集成中的对象模型"></a>4.6.3集成中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象？</p>
<p>从父类继承下来的非静态成员属性都属于子类对象。其中私有成员只是被隐藏了，但是也还是会被继承下去。</p>
<h4 id="4-6-4集成中的构造和析构顺序"><a href="#4-6-4集成中的构造和析构顺序" class="headerlink" title="4.6.4集成中的构造和析构顺序"></a>4.6.4集成中的构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>先构造父类，再构造子类，析构的顺序与构造的顺序相反。</p>
<h4 id="4-6-5继承同名函数处理方式"><a href="#4-6-5继承同名函数处理方式" class="headerlink" title="4.6.5继承同名函数处理方式"></a>4.6.5继承同名函数处理方式</h4><p>问题：当子类与父类出现同名成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重载func()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; s.a &lt;&lt; endl;<span class="comment">//调用子类的成员变量</span></span><br><span class="line">    cout &lt;&lt; s.Base::a &lt;&lt; endl;<span class="comment">//调用父类同名成员变量</span></span><br><span class="line">    </span><br><span class="line">    s.<span class="built_in">func</span>();<span class="comment">//直接调用子类函数</span></span><br><span class="line">    s.Base::<span class="built_in">func</span>();<span class="comment">//调用父类中同名函数</span></span><br><span class="line">    <span class="comment">//如果子类中出现和父类同名的成员函数，子类的同名成员会隐蔽掉父类中所有同名成员函数</span></span><br><span class="line">    <span class="comment">//如果想访问到父类中被隐藏的同名成员函数，需要加作用域</span></span><br><span class="line">    s.Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-6-6继承同名静态成员处理方式"><a href="#4-6-6继承同名静态成员处理方式" class="headerlink" title="4.6.6继承同名静态成员处理方式"></a>4.6.6继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员，需要加作用域</li>
</ul>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式(通过对象和通过类名)</p>
<h4 id="4-6-7多继承语法"><a href="#4-6-7多继承语法" class="headerlink" title="4.6.7多继承语法"></a>4.6.7多继承语法</h4><p>C++允许一个类继承多个类</p>
<p>语法：<code>class 子类 ： 继承方式 父类1,继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议多继承</strong></p>
<p>总结：多继承中如果父类出现了同名的情况，子类使用时候要加作用域</p>
<h4 id="4-6-8菱形继承"><a href="#4-6-8菱形继承" class="headerlink" title="4.6.8菱形继承"></a>4.6.8菱形继承</h4><p><strong>菱形继承概念：</strong></p>
<p>两个派生类继承同一个基类</p>
<p>又有某个类同时继承两个派生类</p>
<p>这种继承被称为菱形继承或者钻石继承。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camel</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alpaca</span>:</span><span class="keyword">public</span> Sheep,<span class="keyword">public</span> Camel&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Alpaca a;</span><br><span class="line">    <span class="comment">//当菱形继承，两个父类拥有相同的数据，需要通过作用域加以区分</span></span><br><span class="line">    <span class="comment">//a.Sheep::age = 18;</span></span><br><span class="line">    <span class="comment">//a.Camel::age = 20;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果采用虚继承的方式，则age只有一份数据，不需要进行区分</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.age&quot;</span> &lt;&lt; a.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-7多态"><a href="#4-7多态" class="headerlink" title="4.7多态"></a>4.7多态</h3><h4 id="4-7-1多态的基本类型"><a href="#4-7-1多态的基本类型" class="headerlink" title="4.7.1多态的基本类型"></a>4.7.1多态的基本类型</h4><p><strong>多态是C++面向对象的三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态：<strong>函数重载</strong> 和 <strong>运算符重载</strong> 属于静态多态，复用函数名</li>
<li>动态多态：派生类和<strong>虚函数</strong>实现运行时多态</li>
</ul>
<p>静态多态和动态多态的区别：</p>
<ul>
<li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//子类重新实现父类虚函数后，就可以实现地址晚绑定了</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址早绑定，在编译阶段就确定了函数的地址</span></span><br><span class="line"><span class="comment">//如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行</span></span><br><span class="line"><span class="comment">//动态多态使用</span></span><br><span class="line"><span class="comment">//父类的指针或者引用 指向子类对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSpeak</span><span class="params">(Animal &amp;a)</span></span>&#123;</span><br><span class="line">    a.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Cat c;</span><br><span class="line">    <span class="built_in">doSpeak</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重写</strong>：函数返回值类型 函数名 参数列表 完全相同</p>
<p><strong>动态多态满足条件</strong> </p>
<ol>
<li>有继承关系</li>
<li>子类要重写父类的虚函数</li>
</ol>
<p><strong>多态使用条件</strong></p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<h4 id="4-7-2多态的底层原理"><a href="#4-7-2多态的底层原理" class="headerlink" title="4.7.2多态的底层原理"></a>4.7.2多态的底层原理</h4><p>子函数的虚函数表内部会替换成子类的虚函数的地址</p>
<p>当父类的指针指向子类对象时候，发生多态</p>
<h4 id="4-7-3纯虚函数和抽象类"><a href="#4-7-3纯虚函数和抽象类" class="headerlink" title="4.7.3纯虚函数和抽象类"></a>4.7.3纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为纯虚函数</p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 &#123;参数列表&#125; = 0</code></p>
<p>当类中有了纯虚函数，这个类也称为抽象类</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="comment">//只要有一个纯虚函数，这个类称为抽象类</span></span><br><span class="line">    <span class="comment">//抽象类函数的特点：</span></span><br><span class="line">    <span class="comment">//1、无法实例化对象</span></span><br><span class="line">    <span class="comment">//2、抽象类的子类	必须要重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func()函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽象类是无法实例化对象的</span></span><br><span class="line">    <span class="comment">//Base b;	错误 </span></span><br><span class="line">    <span class="comment">//new Base;	错误</span></span><br><span class="line">    <span class="comment">//Son s;	子类必须重写父类中的纯虚函数，否则无法实例化对象</span></span><br><span class="line">    </span><br><span class="line">    Base *base = <span class="keyword">new</span> Son;</span><br><span class="line">    base-&gt;<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-7-4虚析构和纯虚析构"><a href="#4-7-4虚析构和纯虚析构" class="headerlink" title="4.7.4虚析构和纯虚析构"></a>4.7.4虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用子类析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构的共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构的区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：<code>virual ~类名()&#123;&#125;</code></p>
<p>纯虚析构法：<code>virtual ~类名() = 0</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Animal</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用虚析构可以解决父类指针释放子类对象不干净的问题</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal  析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//纯虚析构,需要有声明，也需要有实现</span></span><br><span class="line">    <span class="comment">//有了纯虚析构知乎，这个类也属于抽象类，无法实例化对象</span></span><br><span class="line">    <span class="comment">//virtual ~Animal = 0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;猫咪在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Cat</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Cat析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span> name;</span><br><span class="line">            name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string *name; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Animal * animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</li>
<li>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</li>
<li>拥有纯虚析构函数也属于抽象类</li>
</ol>
<h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件进行操作需要包含头文件<fstream></p>
<p>文件类型分为两种：</p>
<ol>
<li>文本文件：文件以文本的ASCII码形式储存在计算机文件当中</li>
<li>二进制文件：文件以文本二进制形式储存在计算机中，用户一般不直接读懂它们</li>
</ol>
<p>操作文件的三大类：</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream：读操作</li>
<li>fstream：读写操作</li>
</ol>
<h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>写文件步骤如下：</p>
<p>1.包含头文件：#include  <fstream></p>
<p>2.创建流对象：ofstream ofs;</p>
<p>3.打开文件：ofs.open(“文件路径”，打开方式);</p>
<p>4.写数据：ofs &lt;&lt; “写入的数据”;</p>
<p>5.关闭文件：ofs.close();</p>
<p>文件打开方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意：</strong>文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如：</strong>用二进制方式写文件<code>ios::binary | ios::out</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//1、包含头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//2、创建该对象</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    <span class="comment">//3、指定打开方式</span></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,ios::out);</span><br><span class="line">    <span class="comment">//4、写内容</span></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;Its my introduction&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;Nice to meet you&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//5、关闭文件</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对比较多</p>
<p>读取步骤如下：</p>
<ol>
<li>包含头文件：<code>#include &lt;iostream&gt;</code></li>
<li>创建对象流：<code>ifstream ifs;</code></li>
<li>打开文件并判断文件是否打开成功：<code>ifs.open(&quot;文件路径&quot;,打开方式);</code></li>
<li>读数据：四种读取方式</li>
<li>关闭文件：<code>ifs.close</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//1、包含头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//2、创建对象流</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、打开文件并判断文件是否打开成功</span></span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,ios::in);</span><br><span class="line">    <span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//4、读数据的四种方法</span></span><br><span class="line">     <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">     <span class="keyword">while</span>(ifs &gt;&gt; buf)&#123;</span><br><span class="line">         cout &lt;&lt; buf &lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// char buf[1024] = &#123;0&#125;;</span></span><br><span class="line">    <span class="comment">// while(ifs.getline(buf,sizeof(buf)))&#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// string buf;</span></span><br><span class="line">    <span class="comment">// while(getline(ifs,buf))&#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//char c;</span></span><br><span class="line">    <span class="comment">//while((c = ifs.get()) != EOF)&#123;//EOF end of file</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; c;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//5、关闭文件</span></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2二进制文件"><a href="#5-2二进制文件" class="headerlink" title="5.2二进制文件"></a>5.2二进制文件</h3><p>以二进制方式对文件进行读写操作</p>
<p>打开方式要指定为：ios::binary</p>
<h4 id="5-2-1写文件"><a href="#5-2-1写文件" class="headerlink" title="5.2.1写文件"></a>5.2.1写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型：<code>ostream &amp; write(const char * buffer ,int len)</code></p>
<p>参数解释：字符指针buffer指向内存中一段储存空间，len是读写的字节数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>,ios::out | ios::binary)</span></span>;</span><br><span class="line">    <span class="comment">//ofs.open(&quot;person.txt&quot;,ios::out | ios::binary);</span></span><br><span class="line">    Person p = &#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>&#125;;</span><br><span class="line">    ofs.<span class="built_in">write</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;p,<span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-2读文件"><a href="#5-2-2读文件" class="headerlink" title="5.2.2读文件"></a>5.2.2读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream &amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段储存空间，len是读写字节数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="C-提高编程"><a href="#C-提高编程" class="headerlink" title="C++提高编程"></a>C++提高编程</h2><h2 id="1模板"><a href="#1模板" class="headerlink" title="1模板"></a>1模板</h2><h3 id="1-1模板的概念"><a href="#1-1模板的概念" class="headerlink" title="1.1模板的概念"></a>1.1模板的概念</h3><p>模板就是<strong>建立通用的模具，大大提高复用性</strong></p>
<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它知识一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h3 id="1-2函数模板"><a href="#1-2函数模板" class="headerlink" title="1.2函数模板"></a>1.2函数模板</h3><ul>
<li>C++另一种编程思想称为泛型编程，主要利用的技术就是模板</li>
<li>C++提供两种模板机制：<strong>函数模板</strong>和<strong>类模板</strong></li>
</ul>
<h4 id="1-2-1函数模板语法"><a href="#1-2-1函数模板语法" class="headerlink" title="1.2.1函数模板语法"></a>1.2.1函数模板语法</h4><p>函数模板作用：</p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体指定，用一个<strong>虚拟类型</strong>来代表。</p>
<p><strong>语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<p>template - 声明创建模板</p>
<p>typename - 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T - 通用数据类型，名称可以替换，通常为大写字母</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//法一：直接调用</span></span><br><span class="line">    <span class="built_in">myswap</span>(a,b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl</span><br><span class="line">         &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">2.2</span>;</span><br><span class="line">    <span class="comment">//法二：指定参数调用</span></span><br><span class="line">    myswap&lt;<span class="keyword">double</span>&gt;(x,y);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl</span><br><span class="line">         &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2函数模板注意事项"><a href="#1-2-2函数模板注意事项" class="headerlink" title="1.2.2函数模板注意事项"></a>1.2.2函数模板注意事项</h4><p>注意事项：</p>
<ul>
<li>自动类型推导，必须推导出一致的数据类型T，才可以使用</li>
<li>模板必须要确定出T的数据类型，才可以使用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">char</span> b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="comment">//swap(a,b);	错误，使用自动类型推导无法推导出一致的T类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//fun();	错误，无法确定出T</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-3函数模板案例"><a href="#1-2-3函数模板案例" class="headerlink" title="1.2.3函数模板案例"></a>1.2.3函数模板案例</h4><p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序函数，可以对不同数据类型数组进行排序</li>
<li>排序则从大到小，排序算法为选择排序</li>
<li>分别利用char数组和int数组进行测试</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(T p[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[min] &gt; p[j])  min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">myswap</span>(p[min],p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//int p[] = &#123;10,8,3,4,2,1&#125;;</span></span><br><span class="line">    <span class="keyword">char</span> p[] = &#123;<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in"><span class="keyword">sizeof</span></span>(p)/<span class="built_in"><span class="keyword">sizeof</span></span>(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">selectSort</span>(p,length);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">        cout &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-4普通函数与函数模板的区别"><a href="#1-2-4普通函数与函数模板的区别" class="headerlink" title="1.2.4普通函数与函数模板的区别"></a>1.2.4普通函数与函数模板的区别</h4><p><strong>普通函数</strong>与<strong>函数模板</strong>区别：</p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="comment">//add(a,c);		错误，自动推导类型，无法进行类型转换</span></span><br><span class="line">    add&lt;<span class="keyword">int</span>&gt;(a,c);<span class="comment">//正确</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：建议使用显示指定类型的方式调用函数模板，因为自己可以确定通用类型</p>
<h4 id="1-2-5普通函数与函数模板的调用规则"><a href="#1-2-5普通函数与函数模板的调用规则" class="headerlink" title="1.2.5普通函数与函数模板的调用规则"></a>1.2.5普通函数与函数模板的调用规则</h4><p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配，优先调用函数模板</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用函数模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a,T b,T c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用函数模板的重载&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(a,b);<span class="comment">//1、调用普通函数</span></span><br><span class="line">    myPrint&lt;&gt;(a,b);<span class="comment">//2、强制调用函数模板</span></span><br><span class="line">    myPrint&lt;&gt;(a,b,c);<span class="comment">//3、调用重载后的函数模板</span></span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);<span class="comment">//4、函数模板有更好的匹配，调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-2-6模板的局限性"><a href="#1-2-6模板的局限性" class="headerlink" title="1.2.6模板的局限性"></a>1.2.6模板的局限性</h4><p><strong>局限性：</strong></p>
<ul>
<li><p>模板的通用性并不是万能的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b)	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1,Person &amp;p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p1.name,p2.name) == <span class="number">0</span> &amp;&amp; p1.age == p2.age)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-3类模板"><a href="#1-3类模板" class="headerlink" title="1.3类模板"></a>1.3类模板</h3><h4 id="1-3-1类模板基本语法"><a href="#1-3-1类模板基本语法" class="headerlink" title="1.3.1类模板基本语法"></a>1.3.1类模板基本语法</h4><p><strong>类模板作用：</strong></p>
<ul>
<li>建立一个通用类，类中的成员数据类型可以不具体指定，用一个虚拟的类型来代表。</li>
</ul>
<p><strong>语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">nametype</span>,<span class="keyword">class</span> <span class="title">agetype</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    nametype name;</span><br><span class="line">    agetype age;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(nametype name,agetype age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="keyword">int</span>&gt; p = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;Qingren&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    p.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-2类模板与函数模板区别"><a href="#1-3-2类模板与函数模板区别" class="headerlink" title="1.3.2类模板与函数模板区别"></a>1.3.2类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">nametype</span>,<span class="keyword">class</span> <span class="title">agetype</span> =</span> <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    nametype name;</span><br><span class="line">    agetype age;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(nametype name,agetype age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="keyword">int</span>&gt; p = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;Qingren&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Person p = new Person(&quot;Qingren&quot;,18); 错误</span></span><br><span class="line">    Person&lt;string&gt; p = <span class="keyword">new</span> <span class="built_in">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-3类模板中成员函数创建时机"><a href="#1-3-3类模板中成员函数创建时机" class="headerlink" title="1.3.3类模板中成员函数创建时机"></a>1.3.3类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有去别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用Person1成员方法&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用Person2成员方法&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span></span><br><span class="line">    T obj;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        obj.<span class="built_in">show1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        obj.<span class="built_in">show2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Myclass&lt;Person1&gt; m;<span class="comment">//这样编译是不会有问题的，只有我们在调用成员函数时，成员函数才会被创建</span></span><br><span class="line">    m.<span class="built_in">test1</span>();<span class="comment">//仅调用test1()也没有问题</span></span><br><span class="line">    <span class="comment">//m.test2(); 如果test1和test2同时调用，就会出现错误</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-4类模板对象做函数参数"><a href="#1-3-4类模板对象做函数参数" class="headerlink" title="1.3.4类模板对象做函数参数"></a>1.3.4类模板对象做函数参数</h4><p>学习目标：</p>
<ul>
<li>类模板实例化出的对象，像函数传参的方式</li>
</ul>
<p>一共有三种传入方式：</p>
<p>1.指定传入类型 —-直接显示对象的数据类型</p>
<p>2.参数模板化—-将对象中的参数变为模板进行传递</p>
<p>3.整个类模板化—-将这个对象类型模板化进行传递</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1,class T2&gt;</span></span><br><span class="line"><span class="function">class <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(T1 name,T2 age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T1 name;</span><br><span class="line">    T2 age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.指定传入的类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;string,<span class="keyword">int</span>&gt;&amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;悟空&quot;</span>,<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1,class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1,T2&gt;&amp;p)</span></span>&#123;</span><br><span class="line">    p2.<span class="built_in">showPerson2</span>(p);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型为：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型为：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="keyword">int</span>&gt;<span class="built_in">p2</span>(<span class="string">&quot;八戒&quot;</span>,<span class="number">90</span>);</span><br><span class="line">    <span class="built_in">printPerson2</span>(p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson3</span><span class="params">(T &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p3.<span class="built_in">showPerson</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T的数据类型&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Person</span>(string,<span class="keyword">int</span>)<span class="built_in">p3</span>(<span class="string">&quot;唐僧&quot;</span>,<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printPerson3</span>(p3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-5类模板与继承"><a href="#1-3-5类模板与继承" class="headerlink" title="1.3.5类模板与继承"></a>1.3.5类模板与继承</h4><p>当类模板碰到继承时，需要注意以下几点：</p>
<ul>
<li>当子类继承的父类是一个模板时，子类在声明的时候，要指定父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活制定出父类中T的类型，子类也需变为类模板</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base&#123;      //这样继承是错误的，必须要知道父类中的T类型，才能继承给子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想灵活指定父类中T类型，子类也需要改变类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>:</span><span class="keyword">public</span> Base&lt;T2&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     	cout &lt;&lt; <span class="string">&quot;T1的类型为：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;T2的类型为：&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;   </span><br><span class="line">    &#125;</span><br><span class="line">    T1 obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-3-6类模板成员函数类外实现"><a href="#1-3-6类模板成员函数类外实现" class="headerlink" title="1.3.6类模板成员函数类外实现"></a>1.3.6类模板成员函数类外实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1,class T2&gt;</span></span><br><span class="line"><span class="function">class <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name,T2 age);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    T1 name;</span><br><span class="line">    T2 age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">Person&lt;T1,T2&gt;::<span class="built_in">Person</span>(T1 name,T2 age)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1,T2&gt;::<span class="built_in">showPerson</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;年龄&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-3-7类模板分文件编写"><a href="#1-3-7类模板分文件编写" class="headerlink" title="1.3.7类模板分文件编写"></a>1.3.7类模板分文件编写</h4><p>存在一个问题：</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li>方式1：直接包含.cpp源文件</li>
<li>方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ul>
<p>主流解决方法是第二种，在主函数文件中包含.hpp文件即可</p>
<h4 id="1-3-8类模板与友元"><a href="#1-3-8类模板与友元" class="headerlink" title="1.3.8类模板与友元"></a>1.3.8类模板与友元</h4><p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类内实现 - 需要提前让编译器知道全局函数的存在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1,class T2&gt;</span></span><br><span class="line"><span class="function">class <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//全局函数 类内实现</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1,T2&gt; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.name &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name,T2 age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 name;</span><br><span class="line">    T2 age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类外实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数配合友元，要提前声明类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="keyword">void</span> printPerson&lt;&gt;(Person&lt;T1,T2&gt; &amp;  p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> printPerson&lt;&gt;(Person&lt;T1,T2&gt; &amp;  p)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.name &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1,class T2&gt;</span></span><br><span class="line"><span class="function">class <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//全局函数 类内实现</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> printPerson&lt;&gt;(Person&lt;T1,T2&gt; &amp;  p);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name,T2 age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 name;</span><br><span class="line">    T2 age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-STL"><a href="#2-STL" class="headerlink" title="2 STL"></a>2 STL</h2><ul>
<li>C++<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></li>
<li>大多数情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作</li>
<li>为了简历数据结构和算法的一套标准，诞生了STL</li>
</ul>
<h3 id="2-1STL基本概念"><a href="#2-1STL基本概念" class="headerlink" title="2.1STL基本概念"></a>2.1STL基本概念</h3><ul>
<li>STL(Standard Template Library,<strong>标准模板库</strong>)</li>
<li>STL从广义上分为：<strong>容器</strong>(container)<strong>算法</strong>(algorithm)<strong>迭代器</strong>(iterator)</li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接</li>
<li>STL几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h3 id="2-2STL六大组件"><a href="#2-2STL六大组件" class="headerlink" title="2.2STL六大组件"></a>2.2STL六大组件</h3><p>STL大体分为六大组件，分别是：<strong>容器、算法、迭代器、仿函数、适配器(配接器)、空间配置器</strong></p>
<ol>
<li>容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂</li>
<li>仿函数：行为类似函数，可作为算法的某种策略</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li>
<li>空间配置器：负责空间的配置与管理</li>
</ol>
<h3 id="2-3-STL中容器、算法、迭代器"><a href="#2-3-STL中容器、算法、迭代器" class="headerlink" title="2.3 STL中容器、算法、迭代器"></a>2.3 STL中容器、算法、迭代器</h3><p><strong>容器：</strong>STL<strong>容器</strong>就是将运用最广泛的一些<strong>数据结构</strong>实现出来</p>
<p>常用的数据结构：数组，链表，树，栈，队列，集合，映射表等</p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种：</p>
<ul>
<li>序列式容器：强调值的排序，序列式容器中的每个元素均有固定位置</li>
<li>关联式容器：二叉树的结构，各元素之间没有严格的物理上的顺序关系</li>
</ul>
<p><strong>算法：</strong></p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>
<p>算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong></p>
<p>质变算法：是指运算过程中会更改去间内的元素内容。例如拷贝，替换，删除等等</p>
<p>非质变算法：是指运算过程中不会更改去间内的元素内容，例如查找，计数，遍历，寻找极值等等</p>
<p><strong>迭代器：</strong></p>
<p>提供一种方法，使之能够依序访问某个容器所含的各个元素。而无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>
<p>迭代器种类：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">种类</th>
<th style="text-align:left">功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">输入迭代器</td>
<td style="text-align:left">对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td style="text-align:left">输出迭代器</td>
<td style="text-align:left">对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td style="text-align:left">前向迭代器</td>
<td style="text-align:left">读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td style="text-align:left">双向迭代器</td>
<td style="text-align:left">读写操作，并能向前和向后操作</td>
<td>读写，支持++、—</td>
</tr>
<tr>
<td style="text-align:left">随机访问迭代器</td>
<td style="text-align:left">读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、—、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody>
</table>
</div>
<p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p>
<h3 id="2-4容器算法叠加器初识"><a href="#2-4容器算法叠加器初识" class="headerlink" title="2.4容器算法叠加器初识"></a>2.4容器算法叠加器初识</h3><h4 id="2-4-1-Vector存放内置数据类型"><a href="#2-4-1-Vector存放内置数据类型" class="headerlink" title="2.4.1 Vector存放内置数据类型"></a>2.4.1 Vector存放内置数据类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向容器中插入数据</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过迭代器访问容器中的数据</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator itBegin = v.<span class="built_in">begin</span>();<span class="comment">//起始迭代器 指向容器中第一个元素</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd = v.<span class="built_in">end</span>();<span class="comment">//结束迭代器 指向容器中最后一个元素的下一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一种遍历方法</span></span><br><span class="line">    <span class="comment">// while(itBegin != itEnd)&#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; *itBegin &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//     itBegin++;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种遍历方法</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),Print);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-Vector存放自定义数据类型"><a href="#2-4-2-Vector存放自定义数据类型" class="headerlink" title="2.4.2 Vector存放自定义数据类型"></a>2.4.2 Vector存放自定义数据类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(string name,<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Person *p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名 = &quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄 = &quot;</span> &lt;&lt; p-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Person*&gt;v;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>,<span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;ddd&quot;</span>,<span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for_each(v.begin(),v.end(),Print);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>();it != v.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名 = &quot;</span> &lt;&lt; (*it)-&gt;name &lt;&lt; <span class="string">&quot; 年龄 = &quot;</span> &lt;&lt; (*it)-&gt;age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-3Vector容器嵌套容器"><a href="#2-4-3Vector容器嵌套容器" class="headerlink" title="2.4.3Vector容器嵌套容器"></a>2.4.3Vector容器嵌套容器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vv;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;Star&quot; &lt;&lt; endl;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v3.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v4.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vv.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    vv.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    vv.<span class="built_in">push_back</span>(v3);</span><br><span class="line">    vv.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = vv.<span class="built_in">begin</span>();it != vv.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>();vit != (*it).<span class="built_in">end</span>();vit++)&#123;</span><br><span class="line">           cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">           cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-STL常用容器"><a href="#3-STL常用容器" class="headerlink" title="3 STL常用容器"></a>3 STL常用容器</h3><h3 id="3-1string"><a href="#3-1string" class="headerlink" title="3.1string"></a>3.1string</h3><h4 id="3-1-1string基本概念"><a href="#3-1-1string基本概念" class="headerlink" title="3.1.1string基本概念"></a>3.1.1string基本概念</h4><p><strong>本质：</strong></p>
<ul>
<li>string是C++风格的字符串，而string本质是一个类</li>
</ul>
<p><strong>string和char*区别</strong></p>
<ul>
<li>char*是一个指针</li>
<li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器</li>
</ul>
<p><strong>特点</strong>：</p>
<p>string类内部封装了很多成员方法</p>
<p>例如：查找find，拷贝copy，删除delete，替换replace，插入insert</p>
<p>string管理char*所分配的内存，不用担心赋值越界和取值越界等，由类内部进行负责</p>
<h4 id="3-1-2string构造函数"><a href="#3-1-2string构造函数" class="headerlink" title="3.1.2string构造函数"></a>3.1.2string构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">string();//创建一个空字符串</span></span><br><span class="line"><span class="comment">string(const char* s);//使用字符串s初始化</span></span><br><span class="line"><span class="comment">string(const string&amp; str);//使用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="comment">string(int n,char c);//使用n个字符串c初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s1;<span class="comment">//默认构造</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>;<span class="comment">//使用C语言风格字符串初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>;<span class="comment">//拷贝构造出s3</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>)</span></span>;<span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-3string的赋值操作"><a href="#3-1-3string的赋值操作" class="headerlink" title="3.1.3string的赋值操作"></a>3.1.3string的赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p><strong>赋值函数原型：</strong></p>
<ul>
<li>string&amp; operator=(const char <em> s);    //char</em>类型字符串赋值给当前的字符串</li>
<li>string&amp; operator=(const string &amp;s);   //把字符串s赋给当前的字符串</li>
<li>string&amp; operator=(char c);   //字符赋值给当前字符串</li>
<li>string&amp; assign(const char *s);   //把字符串s赋给当前字符串</li>
<li>string&amp; assign(const char *s,int n);   //把字符串s的前n个字符串赋给当前的字符串</li>
<li>string&amp; assign(const string &amp;s );    //把字符串s赋给当前字符串</li>
<li>string&amp; assign(int n,char c);    //用n个字符串c赋值给当前字符串</li>
</ul>
<h4 id="3-1-4string字符串拼接"><a href="#3-1-4string字符串拼接" class="headerlink" title="3.1.4string字符串拼接"></a><img src="C:\Users\93963\AppData\Roaming\Typora\typora-user-images\image-20201001174515725.png" alt="image-20201001174515725">3.1.4string字符串拼接</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; operator+=(const char * str);</code>    //重载+=操作符</li>
<li><code>string&amp; operator+=(const char c);</code>    //重载+=操作符</li>
<li><code>string&amp; operator+=(const string &amp;str);</code>    //重载+=操作符</li>
<li><code>string&amp; append(const char *s);</code>    //把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s,int n);</code>    //把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code>    //同operator+=(const string &amp;str)</li>
<li><code>string&amp; append(const string &amp;s,int pos,int n)</code>    //字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<h4 id="3-1-5字符串查找和替换"><a href="#3-1-5字符串查找和替换" class="headerlink" title="3.1.5字符串查找和替换"></a>3.1.5字符串查找和替换</h4><p><img src="C:\Users\93963\AppData\Roaming\Typora\typora-user-images\image-20201001174515725.png" alt="image-20201001174515725"></p>
<ul>
<li>find查找是从左往后，rfind从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h4 id="3-1-6字符串的比较"><a href="#3-1-6字符串的比较" class="headerlink" title="3.1.6字符串的比较"></a>3.1.6字符串的比较</h4><p><strong>功能描述：</strong></p>
<ul>
<li>字符串之间的比较</li>
</ul>
<p><strong>比较方式：</strong></p>
<ul>
<li>字符串比较是按字符的ASCII码进行对比</li>
</ul>
<p>= 返回   0</p>
<p>>返回   1</p>
<p>\&lt; 返回  -1</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int compare(const string &amp;s) const</code>  //与字符串s比较</li>
<li><code>int compare(const char *s) const;</code>   //与字符串s比较</li>
</ul>
<h4 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p>
<ul>
<li><p><code>char&amp; operator[](int n);</code>    //通过[]方式存取字符</p>
</li>
<li><p><code>char&amp; at(int n);</code>     //通过at方法获取字符</p>
</li>
</ul>
<h4 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h4><ul>
<li><code>string&amp; insert(int pos,const char* s)</code>    //插入字符串</li>
<li><code>string&amp; insert(int pos,const string&amp; str)</code>    //插入字符串</li>
<li><code>string&amp; insert(int pos,int n,char c);</code>    //在指定位置插入n个字符</li>
<li><code>string&amp; erase(int pos,int n = npos);</code>    //删除从pos开始的n个字符</li>
</ul>
<h4 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h4><p><code>string substr(int pos = 0,int n = npos) const;</code>    //返回由pos开始的n个字符串组成的字符串</p>
<h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><ul>
<li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li>
<li>不同之处在于数组是静态空间，而vector可以动态扩展</li>
<li>动态扩展并不是在原空间之后续接新空间，而是找更大的内存空间，然后将元数据拷贝到新空间，释放原空间</li>
</ul>
<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h4 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h4><p><code>vector&lt;T&gt; v;</code>    //采用模板实现类实现，默认构造函数</p>
<p><code>vector(v.begin(),v.end());</code>    //将v[begin(),end()]区间中的元素拷贝给本身</p>
<p><code>vector(n,elem);</code>    //构造函数将n个elem拷贝给本身</p>
<p><code>vector(const vector &amp;vec);</code>    //拷贝构造函数</p>
<h4 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h4><ul>
<li><code>vector&amp; operator=(cosnt vector &amp;vec);</code>    //重载等号操作符</li>
<li><code>assign(beg,end);</code>    //将[beg,end) 前闭后开 区间中的数据拷贝赋值给本身</li>
<li><code>assign(n,elem);</code>    //将n个elem拷贝赋值给本身</li>
</ul>
<h4 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4 vector容量和大小"></a>3.2.4 vector容量和大小</h4><ul>
<li><code>empty();</code>    //判断容器是否为空</li>
<li><code>capacity();</code>    //容器的容量</li>
<li><code>size();</code>     //返回容器中元素个数</li>
<li><code>resize(int num);</code>    //重新指定容器的长度为num，若容器变长，则以默认值填充新的位置，如果容器变短，则末尾超出容器长度的元素被删除</li>
<li><code>resize(int num,elem);</code>    //重新指定容器的长度为num，若容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</li>
</ul>
<h4 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h4><ul>
<li><code>push_back(ele);</code>    //尾部插入元素ele</li>
<li><code>pop_back();</code>    //删除最后一个元素</li>
<li><code>insert(const_iterator pos,ele);</code>    //迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos,int count,ele);</code>    //迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code>    //删除迭代器指向的元素</li>
<li><code>erase(const_iterator start,const_itrator end);</code>//删除迭代器从start到end之间的元素</li>
<li><code>clear();</code>    //删除容器中的所有元素</li>
</ul>
<h4 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h4><ul>
<li><code>at(int idx);</code>    //返回索引idx指向的数据</li>
<li><code>operator[];</code>    //返回索引idx指向的数据</li>
<li><code>front();</code>    //返回容器中第一个数据元素</li>
<li><code>back();</code>    //返回容器中最后一个数据元素</li>
</ul>
<h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><ul>
<li><code>swap(vec);</code>    //将vec与本身的元素互换</li>
</ul>
<h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><ul>
<li><code>reserve(int len);</code>    //容器预留len个元素长度，预留位置不初始化，元素不可访问</li>
</ul>
<h3 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h4><ul>
<li>双端数组，可以对头端进行插入删除操作</li>
</ul>
<p><strong>deque与vector区别：</strong></p>
<ul>
<li>vector对于头部的插入删除效率较低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度会比vector快</li>
<li>vector访问元素时的速度会比deque快，这和两者内部实现有关</li>
</ul>
<p><strong>deque内部工作原理：</strong></p>
<ul>
<li>deque内部有一个中控器，维护每段缓冲区中的内容，缓冲区存放真实数据。</li>
<li><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
</li>
<li><p>deque容器的迭代器也是支持随机访问的</p>
</li>
</ul>
<h4 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h4><ul>
<li><code>deque&lt;T&gt; deq;</code></li>
<li><code>deque(beg,end); //将[beg,end)区间中的元素拷贝给本身</code></li>
<li><code>deque(n,elem); //将n个elem拷贝给本身</code></li>
<li><code>deque(const deque &amp;deq); //拷贝构造函数</code></li>
</ul>
<h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><ul>
<li><code>deque&amp; operator=(const deque &amp;deq);  //重载登号操作</code></li>
<li><code>assign(beg,end);   //将[beg,end)区间中的元素拷贝给本身</code></li>
<li><code>assign(n,elem);   //将n个elem拷贝给本身</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test::test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test is ready&quot;</span> &lt;&lt; endl;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d2 = d1;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d3;</span><br><span class="line">    d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>()+<span class="number">1</span>,d1.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d4;</span><br><span class="line">    d4.<span class="built_in">assign</span>(<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><ul>
<li><code>deque.empty();   //判断容器是否为空</code></li>
<li><code>deque.size();   //返回容器中元素的个数</code></li>
<li><code>deque.resize(num);   //重新指定容器的长度为num，若容器变长，则默认填充新位置；若变短，则超出容器长度的元素将被删除</code></li>
<li><code>deque.resize(num,elem);   //重新指定容器的长度为num，若容器变长，则用elem填充新位置；若变短，则超出容器长度的元素将被删除</code></li>
</ul>
<h4 id="3-3-5-deque插入和删除"><a href="#3-3-5-deque插入和删除" class="headerlink" title="3.3.5 deque插入和删除"></a>3.3.5 deque插入和删除</h4><p>两段的插入操作：</p>
<ul>
<li><code>push_back(elem);   //在容器尾部插入一个数据</code></li>
<li><code>push_front(elem);   //在容器头部插入一个数据</code></li>
<li><code>pop_back();   //删除容器最后一个数据</code></li>
<li><code>pop_front();   //删除容器第一个数据</code></li>
</ul>
<p>指定位置的操作：</p>
<ul>
<li><code>insert(pos,elem);   //在pos处插入elem元素的拷贝，返回数据的位置</code></li>
<li><code>inser(pos,n,elem);   //在pos处插入n个elem数据，无返回值</code></li>
<li><code>inser(pos,beg,end);   //在pos处插入[beg,end]区间的数据，无返回值</code></li>
<li><code>clear();   //清空容器所有数据</code></li>
<li><code>erase(beg,end);   //删除[beg,end]区间的数据，返回下一个数据的位置</code></li>
<li><code>erase(pos);   //删除pos数据，返回下一个数据的位置</code></li>
</ul>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="1-new出来的是指针"><a href="#1-new出来的是指针" class="headerlink" title="1 new出来的是指针"></a>1 new出来的是指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(string name,<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person *p = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;Qingren&quot;</span>,<span class="number">18</span>);<span class="comment">//这里 new 出来的是一个指向存放在堆区数据的指针</span></span><br><span class="line">    Person r = <span class="built_in">Person</span>(<span class="string">&quot;Yu&quot;</span>,<span class="number">19</span>);<span class="comment">//这样叫显示初始化对象</span></span><br><span class="line">    <span class="function">Person <span class="title">q</span><span class="params">(<span class="string">&quot;Yao&quot;</span>,<span class="number">20</span>)</span></span>;<span class="comment">//隐式初始化对象</span></span><br><span class="line">    cout &lt;&lt; p-&gt;age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (*p).name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-容器对象-end-指针"><a href="#2-容器对象-end-指针" class="headerlink" title="2 容器对象.end()指针"></a>2 容器对象.end()指针</h2><p>容器对象.end()指针指向的是容器内数据的后一位，如果要访问容器中的最后一位数据：<code>*(OB.end() -1 )</code></p>
<h2 id="3-explicit-关键字"><a href="#3-explicit-关键字" class="headerlink" title="3 explicit 关键字"></a>3 explicit 关键字</h2><p>explicit 防止隐式地调用构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">  	  std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>; # 正确</span><br><span class="line"> A a = <span class="number">10</span>; # 错误</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2021/07/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/" rel="next" title="正则表达式笔记">
                  正则表达式笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qingren</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
